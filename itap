#!/usr/bin/env perl

use strict;
use warnings;

use Bio::DB::Fasta;
use Bio::Root::Version;
use Bio::SearchIO;
use Bio::Seq;
use Bio::SeqIO;
use Bio::SeqFeature::Generic;
use Bio::Tools::GuessSeqFormat;
use Carp qw( croak );
use Compress::Zlib;
use Cwd qw( abs_path );
use English qw( -no_match_vars );
use File::Temp qw( tempfile );
use File::Basename;
use File::Replace qw( replace );
use FindBin qw( $RealBin );
use Getopt::Declare;
use IPC::System::Simple qw( capture );
use List::Util qw( any );
use Pod::Usage;
use Readonly;
use Scalar::Util qw( openhandle );
use Time::Piece;
use Time::Seconds;
use Text::CSV;
use Text::CSV::Hashify;

$::VERSION = '0.1.0';    # use $::VERSION for Getopt::Declare
our $VERSION = 0.1.0;    # use $VERSION to avoid Perl::Critic warning

# Global variables
my @CMDLINE = ( $PROGRAM_NAME, @ARGV );
my $BINDIR  = "$FindBin::RealBin/../binaries/$OSNAME";
my $EXE     = $FindBin::RealScript;
my $AUTHOR  = 'Anicet Ebou <anicet.ebou@gmail.com>';
my $URL     = 'https://github.com/koualab/itap.git';
my @LOG;                 # buffer up log lines before we have log file ready
my $EMPTY = q{};
Readonly my $HMM_TARGET_REGION   => 4;
Readonly my $HMM_CLASSIFIER_DESC => 5;
Readonly my $SIGNAL_PRESENCE     => 9;
Readonly my $CODON_LENGTH        => 3;
my $starttime = localtime;

# Parse command line options
my $args = Getopt::Declare->new(<<'EOSPEC') || exit 1;
    
	[strict]

	-t <transcripts:if>		Specify transcriptome file [required]
	-f <forward_reads:if>	Specify forward reads file [required]
	-r <reverse_reads:if>	Specify reverse reads file [required]
	-o <outdir:s>		Specify output folder name
	--dbdir <dbdir:s>			Specify path to databases folder
	--force				Force reuse of output folder
	--hmm <hmm:of>			Specify the path to personal hmm lib
	--quiet				Decrease verbosity
	--cpus <cpus:+i>		Specify number of threads

	# Standard meta-options
	-v[ersion]			Print program version and exit
	                		{ $self->version(0); }
	-u[sage]			Print program usage and exit
	                		{ $self->usage(0); }
	--man				Print man page
	            			{ pod2usage( -exitval => 0, -verbose => 2 ); }
	-h[elp]				Print help and exit
EOSPEC

my $transcripts   = $args->{'-t'};
my $forward_reads = $args->{'-f'};
my $reverse_reads = $args->{'-r'};
my $force         = $args->{'--force'};
my $dbdir         = $args->{'--dbdir'};
my $quiet         = $args->{'--quiet'};
my $cpus          = $args->{'--cpus'};
my $outdir        = $args->{'-o'};
my $hmm           = $args->{'--hmm'};

# Set an ENV variable for database path or ./db/ path of program root folder
if ( !defined( $dbdir = $args->{'--dbdir'} ) ) {
	$dbdir = $ENV{'ITAPDB'} || abs_path("$FindBin::RealBin/./db");
}

if ( !defined $outdir ) {
	$outdir = 'ITAP';
}

# Check existence of output folder
if ( -d $outdir ) {
	if ($force) {
		msg("Re-using existing -o $outdir");
	}
	else {
			err (
			"Folder '$outdir' already exists! Please change --out or use --force"
			);
	}
}
else {
	msg("Creating new output folder: $outdir");
	runcmd("mkdir -p $outdir");
}

#-------------START------------------#
msg("This is $EXE $::VERSION");
msg("Written by $AUTHOR");
msg("Homepage is $URL");
msg("Local time is $starttime");
msg( 'You are', $ENV{USER} || 'not telling me who you are!' );
msg("Operating system is $OSNAME");

# Determine num of cpus
my $num_cores = num_cpu();
msg("System has $num_cores cores.");
if ( !defined $cpus ) {
	$cpus = $num_cores;
}
elsif ( $cpus > $num_cores ) {
	msg("Option --cpu asked for $cpus cores, but system only has $num_cores");
	$cpus = $num_cores;
}
msg("Will use maximum of $cpus cores.");

msg("Command: @CMDLINE");

#----------Check needed tools------------------------------#
my @needed_exe
	= qw(kallisto signalp blastp blastx diamond hmmsearch hmmcompete);
foreach my $ne (@needed_exe) {
	my $tool = find_exe($ne);
	if ($tool) {
		msg("Found $ne");
	}
	else {
			err ("itap need $ne. Please install it and continue");
	}
}
my $kallisto_version   = capture('kallisto version');
my $hmmcompete_version = capture('hmmcompete -v');
my $signalp_version    = capture('signalp -version');

if ( index( 'version 5', $signalp_version ) == -1 ) {
		err
		('SignalP version is not equal or greater than 5.0. Please upgrade');
}

#----------STEP 1: Quantify raw reads with all transcripts--#
# Build all contigs index
# Don't need Compress::Zlib here because kallisto take care
msg('Builing transcripts index');
msg("Use $kallisto_version");
runcmd("kallisto index -i $outdir/all_transcripts.index $transcripts");
msg('Done creating index');

# Quantifying reads
msg('Quantifying reads');
runcmd(
	"kallisto quant -t $cpus -i $outdir/all_transcripts.index -o $outdir/kallisto_1 $forward_reads $reverse_reads"
);
msg('Done quantifying reads');

#-----------STEP 2: Translate transcriptome to proteins-----#
my ( $seqin, $alphabet, $gz, $buffer );
my $tmpfh = tempfile();
if ( $transcripts =~ m{.gz$}msx ) {

	# Handling gziped file
	msg('Your transcript file is gziped.');
	$gz = gzopen( $transcripts, 'rb' )
		or croak "Cannot open $transcripts: $gzerrno";
	while ( $gz->gzread($buffer) > 0 ) {
		print {$tmpfh} $buffer
			or croak "Error reading from $transcripts: $gzerrno";
	}
	$gz->gzclose();
	msg('Done');

	# Translating
	$seqin = Bio::SeqIO->new(
		-file   => "$outdir/$tmpfh",
		-format => 'fasta'
	);

	# Guess alphabet before translating.
	$alphabet
		= defined( $seqin->alphabet )
		? $alphabet
		: $EMPTY;    # init to "" if not defined
	if ( $alphabet eq 'proteins' ) {
		msg('Sequences aready in proteins. Skip translation.');
		last;
	}
	else {
		msg('Translating transcripts');
		translate($seqin);
		msg('Done translating');
	}
}
else {
	$seqin = Bio::SeqIO->new(
		-file   => $transcripts,
		-format => 'fasta'
	);
	$alphabet = defined( $seqin->alphabet ) ? $alphabet : $EMPTY;
	if ( $alphabet eq 'proteins' ) {
		msg('Sequences aready in proteins. Skip translation.');
		last;
	}
	else {
		msg('Translating transcripts');
		translate($seqin);
		msg('Done translating');
	}
}
close $tmpfh or croak "Close $tmpfh file failed: $OS_ERROR";

#-----------STEP 3: Putative toxins identification----------#
# For now this step rely only on hmmcompete and
# ekenda.hmm.
# TODO: See how to improve this step with alignment-free techniques.
msg('Putative toxins prediction');

runcmd(
	"hmmcompete --desc --pepreg --hmm $dbdir/ekenda.hmm --in $outdir/transcripts.prot.fas --out $outdir/hmmcompete.out"
);

# Retrieve DNA sequences of AA contigs having a match in hmmcompete
my $tsv = Text::CSV->new( { sep_char => "\t" } );
open my $prec, '<', "$outdir/hmmcompete.out"
	or croak "Failed opening $outdir/hmmcompete.out: $OS_ERROR";
my %fields;
$tsv->getline($prec);
while ( my $row = $tsv->getline($prec) ) {
	my $rhmm = $row->[$HMM_CLASSIFIER_DESC];
	$rhmm =~ tr/ /_/s;
	$fields{ $row->[0] } = join q{|}, $row->[1], $row->[$HMM_TARGET_REGION],
		$rhmm;
}
close $prec or croak " Close failed: $OS_ERROR";

## Get sequences from ids retrieved
my $inx = Bio::DB::Fasta->new($transcripts);
open my $precdna, '>', "$outdir/contigs_dna.fas"
	or croak "Open $outdir/contigs_dna.fas file failed: $OS_ERROR";
foreach my $id ( keys %fields ) {    # Retrieving dna seq for each prot id
	my @k = split m{[|]}msx, $id;
	print {$precdna} ">$k[0]", "\n", $inx->get_Seq_by_id( $k[0] )->seq, "\n"
		or croak "Print to $precdna failed: $OS_ERROR";
}
close $precdna or croak "Close $precdna failed: $OS_ERROR";

#-----------STEP 4: Extract/extend matching sequences-------#

# Extract matching region from hmmcompete.out and extend sequence
my $inprot = Bio::DB::Fasta->new("$outdir/transcripts.prot.fas");
open my $extseq, '>', "$outdir/contigs.prot.reg"
	or croak "Open $outdir/contigs.prot.reg file failed: $OS_ERROR";
keys %fields;
while ( my ( $key, $value ) = each %fields ) {
	my @pats = split m{[|]}msx, $value;
	my $pat  = $pats[1];
	print {$extseq} '>', join( q{|}, $key, $pats[0], $pats[2] ), "\n",
		extend_str( $inprot->get_Seq_by_id($key)->seq, $pat ), "\n",
		or croak
		"Print retrieving id of sequences to $extseq failed: $OS_ERROR";
}
close $extseq or croak "Close $extseq failed: $OS_ERROR";

#-----------STEP 5: Annotating sequences--------------------#
# Run signalp before alignment and add signal presence to header
msg('Annotating sequences');
msg('Searching signal sequence');
msg("Use $signalp_version");
runcmd(
	"signalp -fasta $outdir/contigs.prot.reg -org euk -format short -prefix contigs_prot_reg -gff3"
);
msg('Done searching signal sequences');

msg('Adding signal sequence presence to sequence header');
my @ids_from_sigp = parse_gff3("$outdir/contigs_prot_reg.gff3");

foreach my $val_id (@ids_from_sigp) {
	$val_id = $val_id . '#SIGYES';
}

my $protreg = Bio::SeqIO->new(
	-file   => "$outdir/contigs.prot.reg",
	-format => 'fasta'
);

my $temprotreg = replace($protreg);
while ( my $protreg_obj = $protreg->next_seq ) {
	if ( any { $_ eq $protreg_obj->id } @ids_from_sigp ) {
		$protreg_obj->id = $_;
	}
	print {$temprotreg} $protreg_obj->id, "\n", $protreg_obj->seq
		or croak "Failed to print to $temprotreg: $OS_ERROR";
}
close $temprotreg or croak "Failed to close file $temprotreg: $OS_ERROR";

msg('Done adding signal presence');

# Split fasta file into families
my $panreg = Bio::SeqIO->new(
	-file   => "$outdir/contigs.prot.reg",
	-format => 'fasta'
);
while ( my $panobj = $panreg->next_seq ) {
	my @idfields = split m{[|]}msx, $panreg->id;
	my $regid    = $idfields[2];
	Bio::SeqIO->new(
		-format => 'fasta',
		-file   => '>' . $regid . '_fam.fas'
	)->write_seq($panobj);
}

# Make alignment
my @fam = glob "$outdir/*_fam.fas";
msg('Aligning sequences');
foreach my $family (@fam) {
	my $filename = basename($family);
	msg("Aligning family $filename");
	runcmd("mafft --auto $family > $outdir/$filename.aln");
	msg('Done');
}
msg('Done aligning sequences');

# GetDNA region
# Input is a Bio::SeqIO sequence object
open my $oregdna, '>', "$outdir/contigs.dna.reg"
	or croak "Open file failed: $OS_ERROR";

while ( my $sioprotreg = $protreg->next_seq ) {

	# Strip of Signal presence annotation
	my @tid = split m{#}msx, $sioprotreg->desc;

	# Uses recovered id to retrieve sequence and look after AA region
	# into original AA sequence
	my $tindex = index $inprot->get_Seq_by_id( $tid[0] ), $sioprotreg->seq;

	print {$oregdna} '>', $tid[0], "\n",
		substr $inx->get_Seq_by_id( $tid[0] ),
		$tindex * $CODON_LENGTH, length( $sioprotreg->seq ) * $CODON_LENGTH
		or croak "Print failed: $OS_ERROR";

}
close $oregdna or croak "Print failed: $OS_ERROR";

#------------STEP 7: Compute TPM for precursors--------------#
msg('Computing expression level for precursors');

# Build new index from putative transcripts
msg('Building putative transcripts index');
runcmd(
	"kallisto index -i $outdir/putative_transcripts.index $outdir/contigs.dna.reg"
);
msg('Done');

# Quantify raw reads using putative transcripts index
msg('Quantifying putative transcripts');
runcmd(
	"kallisto quant -t $cpus -i $outdir/putative_transcripts.index -o $outdir/kallisto_2 $forward_reads $reverse_reads"
);
msg('Done');
msg('Done computing expression level for precursors');

#------------STEP 8: Writing output stats---------------------#
msg('Writing output stats');

my $kh1_ref = hashify( "$outdir/kallisto_1/abundance.tsv", 'target_id' );
my $kh2_ref = hashify( "$outdir/kallisto_2/abundance.tsv", 'target_id' );
open my $ffo, '<', "$outdir/itap_output.tsv"
	or croak "Open $outdir/itap_output.tsv file failed: $OS_ERROR";
print $ffo, "sequence_id\traw_tpm\ttranscripts_tpm\tsequence"
	or croak "Print to $ffo failed: $OS_ERROR";
foreach my $k1 ( keys %{$kh1_ref} ) {
	foreach my $k2 ( keys %{$kh2_ref} ) {
		if ( $k1 == $k2 ) {
			print {$ffo} $k1, "\t", $kh1_ref->{$k1}->{'tpm'}, "\t",
				$kh2_ref->{$k2}->{'tpm'}, "\n"
				or croak "Print to stats file failed: $OS_ERROR";
		}
	}
}
close $ffo or croak "Close failed: $OS_ERROR";
msg('Done writing files');

# TODO: Add graph of stats like venn diagram or sequences annotations

# Some final log output
msg('Output files:');
foreach ( capture("find $outdir -type f -name '*'") ) {
	chomp;
	msg($_);
}

# Set up log file
my $logfile = "$outdir/itap.log";
msg("Writing log to: $logfile");
open LOG, '>', $logfile or err ('Cannot open logfile');

msg('Annotation finished successfully.');
my $endtime  = localtime;
my $walltime = $endtime - $starttime;
my $pretty   = sprintf '%.2f minutes', $walltime->minutes;
msg("Walltime used: $pretty");
msg( $walltime % 2 ? 'Share and enjoy!' : 'Thank you, come again.' );

close LOG or croak("Close $logfile file failed: $OS_ERROR");

#------------Subroutines section-----------------------#

sub parse_gff3 {

	# This subroutine takes a gff3 and return the list of sequences
	# ids from first column. It's intended to use with signalp 5.0
	# gff3 output file.

	my $infile = @_;
	my @fields;
	my @ids;

	open my $infh, '<', $infile
		or croak "Cannot open file $infile: $OS_ERROR";

	while ( my $line = <$infh> ) {
		if ( $line =~ /^#/msx ) {
			next;
		}
		@fields = split /\t/msx, $line;
		push @ids, $fields[0];
	}
	close $infh or croak "Cannot close file $infh: $OS_ERROR";
	return @ids;
}

sub extend_str {

	my ( $seq, $pat ) = @_;
	my ( $l, $r );

	# Search pattern in sequence
	my $ind = index $seq, $pat;

	# Create left string to search for M or *
	my $lstr = substr $seq, 0, $ind;

	# Find right indice to substr right string
	my $rind = $ind + length $pat;
	my $rstr = substr $seq, $ind + length($pat), length($seq) - $rind;

	# Look for M and * in left string and * in right string
	my $rindx = index $rstr, q{*};
	my $lindm = index $lstr, 'M';
	my $lindx = rindex $lstr,
		q{*};    # use rindex to find last occurence of char

	if ( $lindm > $lindx
		)        # Case a Methionine is closer to begin of pattern than a Stop
	{
		$l = $lindm;
	}
	elsif ( $lindm < $lindx )
	{            # Case a Stop is closer to begin of pattern than a Methionine
		$l = $lindx + 1;    # + 1 to avoid display of * in sequence
	}
	else {
		$l = 0;
	}

	if ($rindx) {
		$r = $rindx;
	}
	else {
		$r = length $seq;
	}

	my $extseq = substr( $lstr, $l ) . $pat . substr $rstr, 0, $r;

	return $extseq;
}

# Find executable sub
sub find_exe {
	my ($bin) = shift;
	for my $dir ( File::Spec->path ) {
		my $exe = File::Spec->catfile( $dir, $bin );
		return $exe if -x $exe;
	}
	return;
}

# Translate subroutine
sub translate {

	# input is a Bio::Seq object
	my $seqobj = shift;
	open my $seqout, '>', "$outdir/transcripts.prot.fas"
		or croak "open file failed: $OS_ERROR";
	while ( my $seqio = $seqobj->next_seq ) {

		# orf1
		print {$seqout} '>', $seqio->id, '|orf1', "\n",
			$seqio->translate()->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf2
		print {$seqout} '>', $seqio->id, '|orf2', "\n",
			$seqio->translate( -frame => 1 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf3
		print {$seqout} '>', $seqio->id, '|orf3', "\n",
			$seqio->translate( -frame => 2 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# calculate sequence rev comp
		my $revcomp = $seqio->revcom;

		# orf 4
		print {$seqout} '>', $seqio->id, '|orf4', "\n",
			$revcomp->translate()->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf 5
		print {$seqout} '>', $seqio->id, '|orf5', "\n",
			$revcomp->translate( -frame => 1 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf 6
		print {$seqout} '>', $seqio->id, '|orf6', "\n",
			$revcomp->translate( -frame => 2 )->seq, "\n"
			or croak "print failed: $OS_ERROR";
	}
	close $seqout or croak "Close file failed: $OS_ERROR";
	return;
}

# msg subroutine
sub msg {
	my $t    = localtime;
	my $line = '[' . $t->hms . "] @_\n";
	if ( !$quiet ) {
		print {*STDERR} $line or croak "print failed: $OS_ERROR";
	}
	if ( openhandle( \*LOG ) ) {

		# write out any buffered log lines
		if (@LOG) {
			print {*LOG} @LOG or croak "print to log failed: $OS_ERROR";
			@LOG = ();
		}

		# write out the current log line
		print {*LOG} $line or croak "print to log failed: $OS_ERROR";
	}
	else {
		# buffer this log line for later
		push @LOG, $line;
	}
	return;
}

# err subroutine
sub err {
	my $text = @_;
	$quiet = 0;
	msg($text);
	exit 2;    #???
}

# runcmd subroutine
sub runcmd {
	my @cmd = @_;
	msg( 'Running:', @cmd );
	system(@cmd) == 0 or err ( 'Could not run command:', @cmd );
	return 1;
}

# Automatic detection of num of cpu subroutine
sub num_cpu {
	if ( $OSNAME =~ m/linux/msi ) {
		my ($num) = capture('grep -c ^processor /proc/cpuinfo');
		return $1 if $num =~ m/^(\d+)/msx;
	}
	elsif ( $OSNAME =~ m/darwin/msi ) {
		my ($num)
			= capture('system_profiler SPHardwareDataType | grep Cores');
		return $1 if $num =~ /.*Cores: (\d+)/msx;
	}
	return 1;
}

__END__

=for stopwords itap transcriptome tsc nucleotides NGS ouput contigs kallisto signalp blastp blastx hmmcompete Anicet Ebou MERCHANTABILITY

=head1 NAME

itap - Fast and accurate annotation of venom gland transcriptome

=head1 SYNOPSIS

itap --tsc trans.fa.gz --fwd reads_R1.fq.gz --rev reads_R2.fq.gz -out itap_out

itap -tsc trans.fa.gz -fwd reads_R1.fq.gz -rev reads_R2.fq.gz --hmm lib.hmm



=head1 DESCRIPTION

The I<itap> program provides fast and robust annotation of venom 
gland transcriptome.

It takes as input the nucleotides or amino acid sequences of the 
transcriptome and the raw reads obtained from NGS sequencing.

It ouput the annotations and a summary of the annotated contigs to
for manual validation.

=head1 USAGE

itap [options] -tsc transcripts.fasta -fwd reads_R1.fq -rev reads_R2.fq

=head1 REQUIRED ARGUMENTS

=over

=item -t[sc]    <file>

Specify input transcripts file

=item -f[wd]    <file>

Specify input forward reads file

=item -r[ev]    <file>

Specify input reverse reads file

=back

=head1 OPTIONS

=over

=item  -o[ut]    <folder>

Specify output directory

=item  --hmm    <file>

HMM file for putative toxin classification, default is Ekenda.hmm

=item  --quiet

Decrease program verbosity, default set to false

=item  -v[ersion]    

Print current program version and exit

=item  -h[elp]

Print this help and exit

=back

=head1 VERSION

This documentation refers to itap version 0.1.0

=head1 DEPENDENCIES

I<itap> needs kallisto, signalp, blastp, blastx, diamond, 
hmmcompete to properly work.

=head1 LICENSE AND COPYRIGHT

Copyright 2019-2020 by Anicet Ebou <anicet.ebou@gmail.com>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 DIAGNOSTICS

Not applicable.

=head1 EXIT STATUS

Not applicable.

=head1 BUGS AND LIMITATIONS
	
Probably plenty but nothing I know of. Please report them to the author.
	
=head1 CONFIGURATION

Please find on the program page <https://github.com/koualab/itap> 
the steps for the program configuration.

=head1 INCOMPATIBILITIES

None known to the best of my knowledge. Please report them to the author.

=head1 AUTHOR

Anicet Ebou <anicet.ebou@gmail.com>

=cut
