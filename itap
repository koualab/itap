#!/usr/bin/env perl

use strict;
use warnings;

use Bio::DB::Fasta;
use Bio::Seq;
use Bio::SeqIO;
use Carp qw( croak );
use Compress::Zlib;
use Cwd qw( abs_path );
use English qw( -no_match_vars );
use File::Basename;
use File::Copy;
use File::Path qw( remove_tree );
use File::Replace qw( replace );
use File::Temp qw( tempfile );
use FindBin qw( $RealBin );
use Getopt::Declare;
use IPC::System::Simple qw( run capture EXIT_ANY );
use List::Util qw( any );
use Pod::Usage;
use Readonly;
use Scalar::Util qw( openhandle );
use Time::Piece;
use Time::Seconds;
use Text::CSV;
use Text::CSV::Hashify;

$::VERSION = '0.1.0';    # use $::VERSION for Getopt::Declare
our $VERSION = 0.1.0;    # use $VERSION to avoid Perl::Critic warning

# Global variables
my @CMDLINE = ( $PROGRAM_NAME, @ARGV );
my $BINDIR  = "$FindBin::RealBin/../binaries/$OSNAME";
my $EXE     = $FindBin::RealScript;
my $AUTHOR  = 'Anicet Ebou <anicet.ebou@gmail.com>';
my $URL     = 'https://github.com/koualab/itap.git';
my @LOG;                 # buffer up log lines before we have log file ready
my $EMPTY = q{};
my $SPACE = q{ };

# Define constants using Readonly
Readonly my $HMM_TARGET_REGION   => 4;
Readonly my $HMM_CLASSIFIER_DESC => 5;
Readonly my $CODON_LENGTH        => 3;
Readonly my $NON_EXIST           => -1;
Readonly my $RWE_FOR_OWNER       => 0700;
Readonly my $TARGET_REGION_INDEX => 3;

# Define starttime
my $starttime = localtime;

# Parse command line options
my $args = Getopt::Declare->new(<<'EOSPEC') || exit 1;
    
	[strict]

	-t <transcripts:if>		Specify transcriptome file [required]
	-f <forward_reads:if>	Specify forward reads file [required]
	-r <reverse_reads:if>	Specify reverse reads file [required]
	-o <outdir:s>		Specify output folder name
	--dbdir <dbdir:s>			Specify path to databases folder
	--force				Force reuse of output folder
	--hmm <hmm:of>			Specify the path to personal hmm lib
	--quiet				Decrease verbosity
	--cpus <cpus:+i>		Specify number of threads

	# Standard meta-options
	-v[ersion]			Print program version and exit
	                		{ $self->version(0); }
	-u[sage]			Print program usage and exit
	                		{ $self->usage(0); }
	--man				Print man page
	            			{ pod2usage( -exitval => 0, -verbose => 2 ); }
	-h[elp]				Print help and exit
EOSPEC

my $transcripts   = $args->{'-t'};
my $forward_reads = $args->{'-f'};
my $reverse_reads = $args->{'-r'};
my $force         = $args->{'--force'};
my $dbdir         = $args->{'--dbdir'};
my $quiet         = $args->{'--quiet'};
my $cpus          = $args->{'--cpus'};
my $outdir        = $args->{'-o'};
my $hmm           = $args->{'--hmm'};

# Set an ENV variable for database path or ./db/ path of program root folder
if ( !defined( $dbdir = $args->{'--dbdir'} ) ) {
	$dbdir = $ENV{'ITAPDB'} || abs_path("$FindBin::RealBin/./db");
}

if ( !defined $outdir ) {
	$outdir = 'ITAP';
}

# Check existence of output folder
if ( -d $outdir ) {
	if ($force) {
		msg("Re-using existing -o $outdir");
		remove_tree( $outdir, { safe => 1 } );
		mkdir $outdir, $RWE_FOR_OWNER;
	}
	else {
			err (
			"Folder $outdir already exists!. Please change it using -o or use --force"
			);
	}
}
else {
	msg("Creating new output folder: $outdir");
	mkdir $outdir, $RWE_FOR_OWNER;
}

# START ----------------------------------------------------------------------
msg( 'This is ' . $EXE . $::VERSION );
msg( 'Written by ' . $AUTHOR );
msg( 'Homepage is ' . $URL );
msg( 'Local time is ' . $starttime );
msg( 'You are', $ENV{USER} || 'not telling me who you are!' );
msg( 'Operating system is ' . $OSNAME );

# Determine number of cpus
my $num_cores = num_cpu();
msg("System has $num_cores cores.");
if ( !defined $cpus || $cpus < 0 ) {
	$cpus = 1;
}
elsif ( $cpus == 0 ) {
	$cpus = $num_cores;
}
elsif ( $cpus > $num_cores ) {
	msg("Option --cpu asked for $cpus cores, but system only has $num_cores");
	$cpus = $num_cores;
}
msg("We will use maximum of $cpus cores.");

msg("Your command is: @CMDLINE");

# Check needed tools
my @needed_tools = qw(kallisto signalp hmmcompete);
foreach my $need (@needed_tools) {
	my $tool = find_exe($need);
	if ($tool) {
		msg("Found $need");
	}
	else {
		print_install_msg($need);
	}
}
chomp( my $kallisto_version   = capture('kallisto version') );
chomp( my $hmmcompete_version = capture('hmmcompete -v') );
chomp( my $signalp_version    = capture( [ 0 .. 1 ], 'signalp -version' ) );

if ( index( $signalp_version, 'version 5' ) == $NON_EXIST ) {
		err
		('SignalP version is not equal or greater than 5.0. Please upgrade.');
}

# STEP 1: Quantify raw reads with all transcripts ----------------------------
# Build all contigs index
msg('Builing transcripts index');
msg("Use $kallisto_version");
runcmd(   'kallisto index ' . '-i '
		. "$outdir/all_transcripts.index "
		. "$transcripts" );
msg('Done creating index');

# Quantifying reads
msg('Quantifying reads');
runcmd(   'kallisto quant ' . '-t '
		. $cpus . ' -i '
		. "$outdir/all_transcripts.index " . '-o '
		. "$outdir/kallisto_1 "
		. "$forward_reads $reverse_reads" );
msg('Done quantifying reads');

# STEP 2: Translate transcriptome to proteins---------------------------------
run_translation($transcripts);

# STEP 3: Putative toxins identification--------------------------------------
msg('Putative toxins prediction');
runcmd(   'hmmcompete --desc --pepreg '
		. '--hmm '
		. "$dbdir/ekenda.hmm " . '--in '
		. "$outdir/contigs_prot.fas "
		. '--out '
		. "$outdir/transcripts_hmmcompete_out.txt" );

# Retrieve DNA sequences of AA contigs having a match in hmmcompete

## First, add description of matched families by hmmcompete
## to sequence header.
msg('Adding description of matched families');
my %fields = add_desc_to_ids("$outdir/transcripts_hmmcompete_out.txt");

## Second, get DNA sequences using ids of putatives sequences
## from hmmcompete result.
msg('Getting DNA sequences using ids of putatives sequences');
open my $precdna, '>', "$outdir/contigs_dna.fas"
	or croak "Open $outdir/contigs_dna.fas file failed: $OS_ERROR";
get_dna_seq( $transcripts, $precdna, \%fields );
close $precdna or croak "Close $precdna failed: $OS_ERROR";

# STEP 4: Extract/extend matching sequences-----------------------------------
# Extract matching region from hmmcompete.out and extend sequence
msg('Extracting matching region and extending sequence');
open my $extseq, '>', "$outdir/contigs_prot_reg.fas"
	or croak "Open $outdir/contigs_prot_reg.fas file failed: $OS_ERROR";
extract_seq( \%fields, "$outdir/contigs_prot.fas", $extseq );
close $extseq or croak "Close $extseq failed: $OS_ERROR";

# STEP 5: Annotating sequences------------------------------------------------
# Run signalp before alignment and add signal presence to header
msg('Annotating sequences');
msg('Searching signal sequence');
msg("Use $signalp_version");
runcmd(   'signalp '
		. '-fasta '
		. "$outdir/contigs_prot_reg.fas "
		. '-org euk '
		. '-verbose=false '
		. '-format short '
		. '-prefix contigs_prot_reg '
		. '-gff3' );
move( "$FindBin::RealBin/contigs_prot_reg.gff3",
	"$outdir/contigs_prot_reg.gff3" );
move(
	"$FindBin::RealBin/contigs_prot_reg_summary.signalp5",
	"$outdir/contigs_prot_reg_summary.signalp5"
);
msg('Done searching signal sequences');

msg('Adding signal sequence presence to sequence header');
add_signal_presence( "$outdir/contigs_prot_reg.gff3",
	"$outdir/contigs_prot_reg.fas" );
msg('Done adding signal presence');

mkdir "$outdir/famaln", $RWE_FOR_OWNER;

# Split fasta file into families
my $panreg = Bio::SeqIO->new(
	-file   => "$outdir/contigs_prot_reg.fas",
	-format => 'fasta'
);

while ( my $panobj = $panreg->next_seq ) {
	my $seqheader = $panobj->id . $SPACE . $panobj->desc;
	my $regid;
	if ( $seqheader =~ m/(?<=FAM=)(.*?)(?=\s)/msx ) {
		$regid = $1;
	}
	Bio::SeqIO->new(
		-format => 'fasta',
		-file   => '>' . "$outdir/famaln/$regid" . '_fam.fas'
	)->write_seq($panobj);
}

# GetDNA region
# Input is a Bio::SeqIO sequence object
process_get_dna_reg( $transcripts, "$outdir/contigs_prot_reg.fas",
	"$outdir/contigs_dna_reg.fas" );

# STEP 7: Compute TPM for precursors------------------------------------------
msg('Computing expression level for precursors');

# Build new index from putative transcripts
msg('Building putative transcripts index');
runcmd(   'kallisto index' . '-i '
		. "$outdir/putative_transcripts.index "
		. "$outdir/contigs_dna_reg.fas" );
msg('Done');

# Quantify raw reads using putative transcripts index
msg('Quantifying putative transcripts');
runcmd(   'kallisto quant ' . '-t '
		. $cpus . '-i '
		. "$outdir/putative_transcripts.index " . '-o '
		. "$outdir/kallisto_2 "
		. "$forward_reads $reverse_reads" );
msg('Done');
msg('Done computing expression level for precursors');

# STEP 8: Writing output stats------------------------------------------------
msg('Writing output stats');

my $kh1_ref = hashify( "$outdir/kallisto_1/abundance.tsv", 'target_id' );
my $kh2_ref = hashify( "$outdir/kallisto_2/abundance.tsv", 'target_id' );
open my $ffo, '<', "$outdir/itap_output.tsv"
	or croak "Open $outdir/itap_output.tsv file failed: $OS_ERROR";
write_output( $kh1_ref, $kh2_ref, $ffo );
close $ffo or croak "Close failed: $OS_ERROR";
msg('Done writing files');

# Some final log output
msg('Output files:');
foreach ( capture("find $outdir -type f -name '*'") ) {
	chomp;
	msg($_);
}

# Write to log file
my $logfile = "$outdir/itap.log";
msg("Writing log to: $logfile");
open my $LOG, '>', $logfile or err ('Cannot open logfile');
msg('Annotation finished successfully.');
my $endtime  = localtime;
my $walltime = $endtime - $starttime;
my $pretty   = sprintf '%.2f minutes', $walltime->minutes;
msg("Walltime used: $pretty");
msg( $walltime % 2 ? 'Share and enjoy!' : 'Thank you, come again.' );
close $LOG or croak "Close $logfile file failed: $OS_ERROR";

# SUBROUTINES ----------------------------------------------------------------

# Add peptide signal presence to sequence header -----------------------------
sub add_signal_presence {

	my ( $gfffh, $protfile ) = @_;
	my @ids_from_sigp = parse_gff3($gfffh);

	my $protreg = Bio::SeqIO->new(
		-file   => $protfile,
		-format => 'fasta'
	);

	my $temprotreg = replace($protreg);
	while ( my $protreg_obj = $protreg->next_seq ) {
		my $header = $protreg_obj->id . $SPACE . $protreg_obj->desc;
		if ( any { $_ eq $header } @ids_from_sigp ) {
			$header = $header . 'SIG=YES';
		}
		else {
			$header = $header . 'SIG=NO';
		}
		print {$temprotreg} $header, "\n", $protreg_obj->seq
			or croak "Failed to print to $temprotreg: $OS_ERROR";
	}
	close $temprotreg or croak "Failed to close file $temprotreg: $OS_ERROR";

	return;
}

# Parse signalp gff3 output file to retrieve list of sequence ids ------------
sub parse_gff3 {

	# This subroutine takes a gff3 and return the list of sequences
	# ids from first column. It's intended to use with signalp 5.0
	# gff3 output file.

	my ($infile) = @_;

	open my $infh, '<', $infile
		or croak 'Cannot open file ' . $infile . ': ' . $OS_ERROR;
	parse_input_gff3($infh);
	close $infh or croak "Cannot close file $infh: $OS_ERROR";
	return;
}

# Return extended sequence with full header ----------------------------------
sub extract_seq {
	my $hashref  = shift;
	my $protfile = shift;
	my $outfh    = shift;

	my $inprot = Bio::DB::Fasta->new($protfile);

	while ( my ( $key, $value ) = each %{$hashref} ) {
		my @val = split m{[#]}msx, $value;
		print {$outfh} '>', $val[0], "\n",
			extend_str( $inprot->get_Seq_by_id($key)->seq, $val[1] ), "\n",
			or croak
			"Extending sequences failed. See extract_seq sub: $OS_ERROR";
	}
	return;
}

# Get DNA sequence using ids from contigs region file ------------------------
sub get_dna_seq {

	my $contig_file = shift;
	my $outfh       = shift;
	my $refhash     = shift;

	# Works with %hash as a hash reference
	my $inx = Bio::DB::Fasta->new($contig_file);

	foreach my $id ( keys %{$refhash} ) {
		my @k = split m{[_]}msx, $id;

		# Use $#array -1 as shortcut to avoid perl critic for number 4
		my $seqid = join '_', @k[ 0 .. $#k - 1 ];
		print {$outfh} '>' . $seqid, "\n", $inx->get_Seq_by_id($seqid)->seq,
			"\n"
			or croak "Print to $outfh failed: $OS_ERROR";
	}
	return;
}

# Subroutine to process output file to create final output file --------------
sub write_output {
	my ( $hashref1, $hashref2, $outfh ) = @_;

	print $outfh, "sequence_id\traw_tpm\ttranscripts_tpm\tsequence"
		or croak "Print to $ffo failed: $OS_ERROR";

	foreach my $k1 ( keys %{$hashref1} ) {
		foreach my $k2 ( keys %{$hashref2} ) {
			if ( $k1 == $k2 ) {
				print {$outfh} $k1, "\t", $hashref1->{$k1}->{'tpm'}, "\t",
					$hashref2->{$k2}->{'tpm'}, "\n"
					or croak "Print to stats file failed: $OS_ERROR";
			}
		}
	}
	return;
}

# Subroutine to get DNA region corresponding to AA region --------------------
sub process_get_dna_reg {
	my ( $dnafile, $protfile, $outfile ) = @_;
	my $dnaind = Bio::DB::Fasta->new($dnafile);
	open my $outfh, '>', $outfile
		or croak 'Failed to open' . $outfile . ': ' . $OS_ERROR;
	get_dna_reg( $dnaind, "$outdir/contigs_prot_reg.fas", $outfh );
	close $outfh or croak "Failed to close $outfh: $OS_ERROR";
	return;
}

# Private method for process_get_dna_reg -------------------------------------
sub get_dna_reg {

	# Private method for process_get_dna_reg
	my ( $dna_index, $protfile, $outfh ) = @_;
	my $protfh = Bio::SeqIO->new(
		-file   => $protfile,
		-format => 'fasta'
	);
	while ( my $protfh_obj = $protfh->next_seq ) {
		my @arrayid = split m{[_]}msx, $protfh->id;
		my $sid     = join '_', @arrayid[ 0 .. $#arrayid - 1 ];
		my $tindex  = index $dna_index->get_Seq_by_id($sid), $protfh_obj->seq;
		print {$outfh} '>', $protfh_obj->id . $SPACE . $protfh_obj->desc,
			"\n",
			substr $dna_index->get_Seq_by_id($sid),
			$tindex * $CODON_LENGTH, length( $protfh->seq ) * $CODON_LENGTH
			or croak "Print to $outfh failed: $OS_ERROR";
	}
	return;
}

# Subroutine to add family and family description to sequence header ---------
sub add_desc_to_ids {

	# Add Family description to sequence header. Take as input
	# a hmmcompete output file.
	my ($infile) = @_;

	my %seqs_header;
	my $textfile = Text::CSV->new( { sep_char => "\t" } );
	open my $infh, '<', $infile or croak "Cannot open $infile: $OS_ERROR";
	$textfile->getline($infh);
	while ( my $row = $textfile->getline($infh) ) {
		my $new_header = join $SPACE, $row->[0], 'FAM=' . $row->[1],
			'FAMDESC=' . $row->[$HMM_CLASSIFIER_DESC];
		my $seq_desc = $row->[$HMM_TARGET_REGION];
		$seqs_header{ $row->[0] } = $new_header . q{#} . $seq_desc;
	}
	close $infh or croak " Close failed: $OS_ERROR";

	return %seqs_header;
}

# Private method for parse_gff3 ----------------------------------------------
sub parse_input_gff3 {

	# Private method for parse_gff3
	my ($infh) = @_;
	my ( @fields, @ids );
	while ( my $line = <$infh> ) {
		if ( $line =~ /^#/msx ) {
			next;
		}
		@fields = split /\t/msx, $line;
		push @ids, $fields[0];
	}
	return @ids;
}

# Extend AA sequences to sequence with start and stop codon ------------------

sub extend_str {

	my ( $seq, $pat ) = @_;
	my ( $l, $r );

	# Search pattern in sequence
	my $ind = index $seq, $pat;

	# Create left string to search for M or *
	my $lstr = substr $seq, 0, $ind;

	# Find right indice to substr right string
	my $rind = $ind + length $pat;
	my $rstr = substr $seq, $ind + length($pat), length($seq) - $rind;

	# Look for M and * in left string and * in right string
	my $rindx = index $rstr, q{*};
	my $lindm = index $lstr, 'M';

	# use rindex to find last occurence of char
	my $lindx = rindex $lstr, q{*};

	# Case a Methionine is closer to begin of pattern than a Stop
	if ( $lindm > $lindx ) {
		$l = $lindm;
	}
	elsif ( $lindm < $lindx )
	{    # Case a Stop is closer to begin of pattern than a Methionine
		$l = $lindx + 1;    # + 1 to avoid display of * in sequence
	}
	else {
		$l = 0;
	}

	if ($rindx) {
		$r = $rindx;
	}
	else {
		$r = length $seq;
	}

	my $extseq = substr( $lstr, $l ) . $pat . substr $rstr, 0, $r;

	return $extseq;
}

# Print useful error for user missing some tools -----------------------------
sub print_install_msg {
	my $tool = @_;
	if ( $tool eq 'kallisto' ) {
			err (
			  'Kallisto not found. Installation instruction can be found at '
			. 'https://github.com/patcherlab/kallisto.git' );
	}
	elsif ( $tool eq 'hmmcompete' ) {
			err (
			'Hmmcompete not found. Installation instruction can be found at '
			. 'https://github.com/koualab/hmmcompete.git' );
	}
	elsif ( $tool eq 'signalp' ) {
			err (
			  'SignalP not found. Installation instruction can be found at '
			. 'http://www.cbs.dtu.dk/services/SignalP/portable.php' );
	}
	return;
}

# Find executable subroutine -------------------------------------------------
sub find_exe {
	my ($bin) = shift;
	for my $dir ( File::Spec->path ) {
		my $exe = File::Spec->catfile( $dir, $bin );
		return $exe if -x $exe;
	}
	return;
}

# Subroutine to run translation taking into account file compression ---------
sub run_translation {

	my ($infh) = @_;
	my $outfh = tempfile();
	my $alphabet;
	my $buffer;
	my $seqin;

	if ( $infh =~ m{.gz$}msx ) {

		# Handling gziped file
		msg('Your transcript file is gziped.');
		my $gzip = gzopen( $infh, 'rb' )
			or croak "Cannot open $infh: $gzerrno";
		while ( $gzip->gzread($buffer) > 0 ) {
			print {$outfh} $buffer
				or croak "Error reading from $infh: $gzerrno";
		}
		$gzip->gzclose();
		msg('Done');

		# Translating
		$seqin = Bio::SeqIO->new(
			-file   => "$outdir/$outfh",
			-format => 'fasta'
		);

		# Guess alphabet before translating.
		$alphabet
			= defined( $seqin->alphabet )
			? $alphabet
			: $EMPTY;    # init to "" if not defined
		if ( $alphabet eq 'proteins' ) {
				err (
				'Sequences already in proteins. Please provide DNA sequences.'
				);
		}
		else {
			msg('Translating transcripts');
			translate( $seqin, "$outdir/contigs_prot.fas" );
			msg('Done translating');
		}
	}
	else {
		$seqin = Bio::SeqIO->new(
			-file   => $infh,
			-format => 'fasta'
		);
		$alphabet = defined( $seqin->alphabet ) ? $alphabet : $EMPTY;
		if ( $alphabet eq 'proteins' ) {
				err
				('Sequences aready in proteins. Please provide DNA sequences.'
				);
		}
		else {
			msg('Translating transcripts');
			translate( $seqin, "$outdir/contigs_prot.fas" );
			msg('Done translating');
		}
	}
	close $outfh or croak "Close $outfh file failed: $OS_ERROR";

	return;

}

# Translate a DNA sequence file into 6 ORF -----------------------------------
sub translate {
	my ( $sequence_obj, $outfile ) = @_;
	open my $seqout, '>', $outfile or croak "open file failed: $OS_ERROR";
	_do_translation( $sequence_obj, $seqout );
	close $seqout or croak "Close file failed: $OS_ERROR";
	return;
}

# Private method for translate subroutine ------------------------------------
sub _do_translation {
	my ( $seqobj, $seqout ) = @_;

	while ( my $seqio = $seqobj->next_seq ) {

		# orf1
		print {$seqout} '>', $seqio->id, '_orf1', "\n",
			$seqio->translate()->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf2
		print {$seqout} '>', $seqio->id, '_orf2', "\n",
			$seqio->translate( -frame => 1 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf3
		print {$seqout} '>', $seqio->id, '_orf3', "\n",
			$seqio->translate( -frame => 2 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# calculate sequence rev comp
		my $revcomp = $seqio->revcom;

		# orf 4
		print {$seqout} '>', $seqio->id, '_orf4', "\n",
			$revcomp->translate()->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf 5
		print {$seqout} '>', $seqio->id, '_orf5', "\n",
			$revcomp->translate( -frame => 1 )->seq, "\n"
			or croak "print failed: $OS_ERROR";

		# orf 6
		print {$seqout} '>', $seqio->id, '_orf6', "\n",
			$revcomp->translate( -frame => 2 )->seq, "\n"
			or croak "print failed: $OS_ERROR";
	}
	return;
}

# Print message to screen ----------------------------------------------------
sub msg {
	my $t    = localtime;
	my $line = '[' . $t->hms . "] @_\n";
	if ( !$quiet ) {
		print {*STDERR} $line or croak "print failed: $OS_ERROR";
	}
	if ( openhandle($LOG) ) {

		# write out any buffered log lines
		if (@LOG) {
			print {$LOG} @LOG or croak "print to log failed: $OS_ERROR";
			@LOG = ();
		}

		# write out the current log line
		print {$LOG} $line or croak "print to log failed: $OS_ERROR";
	}
	else {
		# buffer this log line for later
		push @LOG, $line;
	}
	return;
}

# Print error and exit -------------------------------------------------------
sub err {
	my @text = @_;
	$quiet = 0;
	msg(@text);
	exit 2;
}

# Run command subroutine -----------------------------------------------------
sub runcmd {
	my @cmd = @_;
	msg( 'Running:', @cmd );
	system(@cmd) == 0 or err ( 'Could not run command:', @cmd );
	return 1;
}

# Automatic detection of number of cpu ---------------------------------------
sub num_cpu {
	if ( $OSNAME =~ m/linux/msi ) {
		my ($num) = capture('grep -c ^processor /proc/cpuinfo');
		return $1 if $num =~ m/^(\d+)/msx;
	}
	elsif ( $OSNAME =~ m/darwin/msi ) {
		my ($num)
			= capture('system_profiler SPHardwareDataType | grep Cores');
		return $1 if $num =~ /.*Cores: (\d+)/msx;
	}
	return 1;
}

# POD HELP -------------------------------------------------------------------
__END__

=for stopwords Koua ekenda.hmm itap transcriptome tsc nucleotides NGS ouput contigs
=for stopwords kallisto signalp blastp blastx hmmcompete Anicet Ebou MERCHANTABILITY

=head1 NAME

itap - Fast and accurate annotation of venom gland transcriptome

=head1 SYNOPSIS

itap --tsc trans.fa.gz --fwd reads_R1.fq.gz --rev reads_R2.fq.gz -out itap_out

itap -tsc trans.fa.gz -fwd reads_R1.fq.gz -rev reads_R2.fq.gz --hmm lib.hmm



=head1 DESCRIPTION

The I<itap> program provides fast and robust annotation of venom 
gland transcriptome.

It takes as input the nucleotides or amino acid sequences of the 
transcriptome and the raw reads obtained from NGS sequencing.

It ouput the annotations and a summary of the annotated contigs to
for manual validation.

=head1 USAGE

itap [options] -tsc transcripts.fa -fwd reads_R1.fq -rev reads_R2.fq

=head1 REQUIRED ARGUMENTS

=over

=item -t[sc]    <file>

Specify input transcripts file

=item -f[wd]    <file>

Specify input forward reads file

=item -r[ev]    <file>

Specify input reverse reads file

=back

=head1 OPTIONS

=over

=item  -o[ut]    <folder>

Specify output directory

=item  --hmm    <file>

HMM file for putative toxin classification, default is ekenda.hmm

=item  --quiet

Decrease program verbosity, default set to false

=item  -v[ersion]    

Print current program version and exit

=item  -h[elp]

Print this help and exit

=back

=head1 VERSION

This documentation refers to itap version 0.1.0

=head1 DEPENDENCIES

I<itap> needs kallisto, signalp, and hmmcompete to properly work.

=head1 LICENSE AND COPYRIGHT

Copyright 2019-2020 by Anicet Ebou <anicet.ebou@gmail.com>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 DIAGNOSTICS

Not applicable.

=head1 EXIT STATUS

Not applicable.

=head1 BUGS AND LIMITATIONS
	
Probably plenty but nothing I know of. Please report them to the author.
	
=head1 CONFIGURATION

Please find on the program page <https://github.com/koualab/itap> 
the steps for the program configuration.

=head1 INCOMPATIBILITIES

None known to the best of my knowledge. Please report them to the author.

=head1 AUTHOR

Anicet Ebou <anicet.ebou@gmail.com>
Dominique Koua <koua.dominique@gmail.com>

=cut
